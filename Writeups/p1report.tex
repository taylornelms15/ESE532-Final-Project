\documentclass{article}
\usepackage[margin=0.5in]{geometry}

\usepackage{listings}
\usepackage{enumitem}
\usepackage{appendix}
\usepackage{graphicx}


\title{ESE532 Project P1 Report}
\author{Ritika Gupta, Taylor Nelms, and Nishanth Shyamkumar}

\begin{document}

\maketitle


\begin{enumerate}
\item%1
Our group makeup is Ritika Gupta, Taylor Nelms, and Nishanth Shyamkumar.

\item%2
\begin{enumerate}[label=(\alph*)]
\item%a
We end up with $64ns$ to process each $64b$ word of input, which comes out to $76.8$ (so, $76$) cycles for a $1.2$GHz processor.

\item%b
By similar logic as the last question, with a $200$MHz clock, we end up with $12.8$ (so, $12$) cycles to process all of the input.

\end{enumerate}%2

\item%3
\begin{enumerate}[label=(\alph*)]
\item%a
\begin{enumerate}[label=(\roman*)]
\item%i
\textbf{Content-Defined Chunking}:\newline
\begin{lstlisting}[language=python]
skip input to minChunkSize - windowSize
buffer = input[minChunkSize - windowSize : minChunkSize]
curHash = 0
for byte in buffer:
    curHash += hash(byte)
if curHash == 0:
    markChunkBreak()
else:
    while (curHash != 0 and (notAtMaxChunkSize())):
        curHash -= hash(buffer[0])
        moveBufferWindow()
        readNextByte()
        curHash += hash(buffer[windowSize - 1])
    markChunkBreak()
\end{lstlisting}
\item%ii
\textbf{SHA-256}:
\item%iii
\textbf{Chunk Matching}:
\item%iv
\textbf{LZW Encoding}:

\end{enumerate}%2a
\item%b

\item%c

\item%d

\item%e

\end{enumerate}%3

\item%4
\begin{enumerate}[label=(\alph*)]
\item%a

\item%b

\item%c

\item%d

\item%e

\end{enumerate}%4

\item%5
\begin{enumerate}[label=(\alph*)]
\item%a

\item%b

\item%c

\item%d

\item%e

\item%f

\end{enumerate}%5

\end{enumerate}%doc


\begin{appendices}
%\section{2m Filter.cpp}\label{2m}
%\lstinputlisting[language=C]{code/Filter.cpp}
%\section{1h mmult\_accel.cpp}\label{1hB}
%\lstinputlisting[language=C]{code/mmult_accel.cpp}
%\section{1h mmult\_accel.h}\label{1hC}
%\lstinputlisting[language=C]{code/mmult_accel.h}


\end{appendices}





\end{document}